{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\b\f0\fs96\lang29 NACKADEMIN\par
\par

\pard\sa200\sl276\slmult1\ul\b0\fs20 Sarhad Bahrami\par
Sarhad94127@hotmail.com\par
\ulnone\fs22\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sa200\sl276\slmult1\i Hur jag tog mig tillv\'e4ga f\'f6r att ge grundl\'e4ggande f\'f6rklaringar av drivrutinen\par
{\pntext\f0 2.\tab}Drivrutinens funktioner och sammanfattning\par

\pard\sa200\sl276\slmult1\par
\b\i0\fs28 1.  \b0\fs24 Jag b\'f6rjade med att f\'f6rst best\'e4mma mig f\'f6r hur jag skulle kunna slutf\'f6ra min uppgift p\'e5 den korta tiden som jag har, och best\'e4mde mig f\'f6r att f\'f6rs\'f6ka f\'f6rklara varje kodrad i filerna detaljerat men \'e4ven inom en rimlig kort text f\'f6r att texten inte ska ta \'f6ver f\'f6r mycket utav kodfilerna. F\'f6r att jag skulle kunna f\'f6rklara varje kodrad beh\'f6vde jag skaffa mig en grundl\'e4ggande f\'f6rst\'e5else f\'f6r STM32 kortet och dess dokumentation. \par
Jag spenderade mycket tid p\'e5 relevanta sidor p\'e5 STM32 dokumentationen som hade med koderna att g\'f6ra. Jag gick igenom de relevanta kodraderna och j\'e4mf\'f6rde det med dokumentationen f\'f6r att f\'f6rst\'e5 syftet med koden samt dess funktion. Om jag st\'f6tte p\'e5 fr\'e5gor eller problem kring koden gjorde jag ytterligare research p\'e5 n\'e4tet som exempelvis youtube, google och diskussionforum kring UART och STM32 kortet f\'f6r hj\'f6lpsamma r\'e5d och tips, samt de videos p\'e5 studentportalen. Efter att jag skrivit mina f\'f6rklaringar kring koderna gick jag igenom dom igen f\'f6r att s\'e4kerst\'e4lla en god f\'f6rklaring och att det \'e4r r\'e4tt i sammanhanget. \par
\b\fs28 2. \b0\fs24 Jag b\'f6rjade med att f\'f6rklara koden i '\b uart.c' \b0 filen eftersom att det var h\'e4r vi implementerade funktionerna och konfigurationerna kring hur UART kommunikationsprotokolllet ska se ut. Inom void USART2_Init(void), st\'e4llde vi in konfigurationerna, det var h\'e4r vi aktiverade USART2 f\'f6r klockan samt klocktillg\'e5ngen f\'f6r porten vi anv\'e4nde oss utav, vilket var GPIO port A, och mer.\par
Inom void USART2_Init(void) angav vi \'e4ven de l\'e4gen som pinsen i porten ska ha f\'f6r att sedan aktivera alternativ funktions l\'e4ge f\'f6r de pinsen med hj\'e4lp utav MODER registret (GPIOA->MODER &= ~0x00F0; och GPIOA->MODER |= 0x00A0; ). Efter att vi aktiverat alternativs l\'e4ge rensade vi tidigare eventuella konfigurationer f\'f6r denna, vilket skapar en ren utg\'e5ngsl\'e4ge f\'f6r oss att konfigurera. Vi satte sedan det alternativa l\'e4gen p\'e5 pinsen till att fungera som transmitter och reciever f\'f6r att kunna l\'e4sa och ta emot data. \par
Forts\'e4ttningen av koden i uart.c filen s\'e4tter baudraten till 9600bps, och med hj\'e4lp utav kontrollregistret satte vi antalet bitar och stopbitar till 8 bitar och 1 stopbit, samt paritetskontrollet vilket vi inte aktiverade. Sedan aktiverade vi USART modulen vid CR1 genom att s\'e4tta bit 13 till 1, n\'e4r USART2 \'e4r aktiverat kan vi anv\'e4nda den f\'f6r seriell datakommunikation med de konfigurationer vi satte det till. De tv\'e5 funktionerna vid slutet av uart.c (write och read) l\'e4ser utmatning och inmatning, det anv\'e4nds f\'f6r att skicka en 8-bitars data till en UART-enhet, alst\'e5 att n\'e4r man anropar p\'e5 funktionen och anger teckenkod som argument (ch) kontrollerar funktionen f\'f6rst om bufferten \'e4r tom och redo att ta emot byten och sedan skickas denna byte. Read funktionen g\'f6r n\'e4stan likadant fast andra h\'e5llet, den tar emot och l\'e4ser denna 8-bitars data FR\'c5N en UART-enhet.  \par
I v\'e5r \b uart.h \b0 fil s\'e5 \'e4r detta altts\'e5 en header fil som inkluderar alla konfigurationerna fr\'e5n uart.c filen (d\'e5 vi inkluderade uart.h i v\'e5r header i uart.c filen ), om man nu vill anv\'e4nda funktionerna i v\'e5r uart.c fil kan man bara ha uart.h i sin header och de andra inkluderade headerfilerna ger de n\'f6dv\'e4ndiga resurserna och funktionerna f\'f6r att anv\'e4nda UART p\'e5 ett enkelt s\'e4tt.\par
Sedan s\'e5 granskade och kommenterade jag koderna f\'f6r \b 'led.h' \b0 och de var h\'e4r vi konfigurerade GPIO f\'f6r port B denna g\'e5ng och anv\'e4nde oss utav nya definitioner som kallas makron som underl\'e4ttar f\'f6r oss n\'e4r vi implementerar LED funktioner senare i led.c koden, vi definierade GPIOB som LED_PORT och sedan med den nya definitionen definiera klocksignalen f\'f6r porten som LED_PORT_CLOCK och sedan lade vi till fyra olika led lampor och dess f\'e4rger till respektive port i GPIOB, vilket vi senare med hj\'e4lp utav (MODE_BIT) angav l\'e4gena utav portarna som General purpose output mode. Senare i koden s\'e5 numrerade vi de olika f\'e4rgerna med siffror som motsvarar respektive f\'e4rg och sedan \'e4ven statusen p\'e5 lampan (ON eller OFF), siffrorna ska allst\'e5 representera olika tillst\'e5nden och f\'e4rgen p\'e5 LED-lamporna med hj\'e4lp utav 'typedef enum'. Senare i samma kodfil finns det klassen Led, i klassen Led hanterar vi LED-lamporna med privata variabler f\'f6r f\'e4rg och tillst\'e5nd (ON/OFF) och har publika funktioner f\'f6r att \'e4ndra och h\'e4mta tillst\'e5ndet.\par
Konstruktorn i Led klassen tar emot tv\'e5 parametrar: _color av typen LedColor_Type och _state av typen LedState_Type. V\'e4rdet utav dessa tilldelas till privata medlemmar 'color' och 'state'. Genom att s\'e4tta dessa variablar s\'e4tts till privata tar vi nytta av inkapsling vilket hj\'e4lper till att skapa en tydligare och strukturerad kod.\par
\b led.c \b0 inkluderar led.h f\'f6r att koden ska kunna anv\'e4nda definitionerna och funktionerna i led.h filen. I led.c kallar vi f\'f6rst p\'e5 Led funktionen vid klassen led.h/Led och raderna "this->color = _color;" och "this->state = _state;" tilldelar v\'e4rdena av de inkommande parametrarna till de privata medlemmarna i det aktuella LED-objektet, vilket hj\'e4lper oss att h\'e5lla reda p\'e5 dess f\'e4rg och tillst\'e5nd. Sedan i koden aktiverade vi klockan f\'f6r porten (GPIOB), men ist\'e4llet f\'f6r att anv\'e4nda oss utav hexadecimala v\'e4rden anv\'e4nde vi oss utav den nya definitionen som inneh\'e5ller det specifika v\'e4rdet f\'f6r klocksignalen f\'f6r GPIOB-porten (LED_PORT_CLOCK). \par
switch-satsen i led.c-filen tar emot ett v\'e4rde f\'f6r variabeln _color, som tidigare har tilldelats en f\'e4rg (RED, GREEN, YELLOW eller BLUE) fr\'e5n konstruktorn i Led-klassen, och baserat p\'e5 v\'e4rdet av _color utf\'f6rs de \'e5tg\'e4rder som kr\'e4vs f\'f6r att t\'e4nda eller sl\'e4cka den valda LED-lampan i enlighet med dess specifika f\'e4rg, man m\'e5ste altts\'e5 \'e4ndra v\'e4rdet p\'e5 konstruktorn f\'f6r att ange vilken LED man vill styra. \par
Det andra switch satsen tar ocks\'e5 h\'e4nsyn till den f\'e4rg som \'e4r i konstruktorn och baserat p\'e5 den f\'e4rgen k\'f6rs kodraden "LED_PORT->MODER |= LED_RED_MODE_BIT;" f\'f6r den unika f\'e4rgen vilket \'e4ndrar v\'e4rdet p\'e5 MODER registret, vilket aktiverar "General purpose output mode" p\'e5 den pinnen som lampan \'e4r kopplad till och sedan i samma 'case' kontrolleras satusen if(this->state == ON, om lampan \'e4r satt till ON (p\'e5) eller OFF (av). Om statusen av den pinnen \'e4r satt till ON (if(this->state == ON)) s\'e4tter bitpositionen f\'f6r den pinnen ODR-registret till 1. Detta resulterar i att den specifika pinnen aktiveras och lampan t\'e4nds. Detta m\'f6nster upprepas f\'f6r varje f\'e4rg i switch-satsen, vilket g\'f6r att varje LED-lampa kan styras baserat p\'e5 dess f\'e4rg och tillst\'e5nd.\par
Metoden 'getState' i klassen Led anv\'e4nds f\'f6r att f\'e5 tillg\'e5ng till och returnera statusen f\'f6r en LED-lampa.I metoden kontrolleras f\'e4rgen p\'e5 LED-lampan genom att \'e4ven h\'e4r anv\'e4nda oss utav en switch-sats. Varje f\'e4rg har en separat case som f\'f6r n\'e4rvarande inte inneh\'e5ller n\'e5gon kod. Slutligen returneras state, vilket \'e4r statusen f\'f6r den specifika LED-lampan. Beroende p\'e5 f\'e4rgen p\'e5 LED-lampan kommer metoden att returnera dess status. Denna metod anv\'e4nds allts\'e5 f\'f6r att h\'e4mta och returnera statusen f\'f6r en LED-lampa av den specifika f\'e4rg.\par
I \b main.c\b0 -filen inkluderar vi Led.h vid headern, detta inneb\'e4r att all kod som finns i led.h blir tillg\'e4ngliga f\'f6r oss i main.c filen. P\'e5 det s\'e4ttet kan vi anv\'e4nda LED-klassen och dess funktioner.\par
I sj\'e4lva main.c filen utf\'f6rs den huvudsakliga hanteringen av LED-lamporna. Vi skapar tre LED-objekt: led1, led2 och led3. Varje objekt skapas med olika f\'e4rger och tillst\'e5nd genom att anv\'e4nda konstruktorn Led(LedColor_Type _color, LedState_Type _state) som definieras i led.h.\par
Inuti main funktionen anropar vi olika funktioner och metoder f\'f6r att utf\'f6ra olika \'e5tg\'e4rder med LED-lamporna. Till exempel initierar vi UART-kommunikationen genom att anropa funktionen USART2_Init(). Vi \'e4ndrar ocks\'e5 tillst\'e5ndet f\'f6r LED-lamporna genom att anv\'e4nda setState(), och vi h\'e4mtar det aktuella tillst\'e5ndet f\'f6r LED-lamporna med hj\'e4lp av getState(). Dessutom tar vi bort det minne som allokerades f\'f6r led3-objektet genom att anv\'e4nda delete led3.\par
\par
\par
 \b\par
\b0\par
\b\fs22\par
}
 